name: Build bootc image with artifacts
on:
  workflow_dispatch:
    inputs:
      platforms:
        description: 'Platforms to build (comma-separated)'
        required: true
        default: 'linux/amd64,linux/arm64'
      formats:
        description: 'Export formats (comma-separated)'
        required: true
        default: 'anaconda-iso,qcow2'
  push:
    branches:
      - main

jobs:
  # Setup job: Parse build parameters
  setup:
    name: Setup build parameters
    runs-on: ubuntu-latest
    outputs:
      platforms: ${{ steps.setup.outputs.platforms }}
      formats: ${{ steps.setup.outputs.formats }}
      matrix: ${{ steps.setup.outputs.matrix }}
    steps:
      - name: Setup build parameters
        id: setup
        run: |
          # Set platforms (from input or default)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PLATFORMS="${{ github.event.inputs.platforms }}"
            FORMATS="${{ github.event.inputs.formats }}"
          else
            PLATFORMS="linux/amd64,linux/arm64"
            FORMATS="anaconda-iso,qcow2"
          fi
          
          echo "platforms=$PLATFORMS" >> $GITHUB_OUTPUT
          echo "formats=$FORMATS" >> $GITHUB_OUTPUT
          echo "Building for platforms: $PLATFORMS"
          echo "Building formats: $FORMATS"
          
          # Create matrix for build jobs
          MATRIX='{"include":['
          IFS=',' read -ra PLATFORM_ARRAY <<< "$PLATFORMS"
          for i in "${!PLATFORM_ARRAY[@]}"; do
            PLATFORM="${PLATFORM_ARRAY[i]}"
            ARCH="${PLATFORM#linux/}"
            
            if [ "$i" -gt 0 ]; then
              MATRIX="${MATRIX},"
            fi
            
            if [ "$ARCH" = "arm64" ]; then
              RUNNER="ubuntu-24.04-arm"
            else
              RUNNER="ubuntu-latest"
            fi
            
            MATRIX="${MATRIX}{\"platform\":\"$PLATFORM\",\"arch\":\"$ARCH\",\"runner\":\"$RUNNER\"}"
          done
          MATRIX="${MATRIX}]}"
          
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Matrix: $MATRIX"

  # Matrix job: Build the base bootc image for each platform
  build-image:
    name: Build BootC base image
    needs: setup
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    runs-on: ${{ matrix.runner }}
    outputs:
      image: ${{ steps.build.outputs.image }}
      tags: ${{ steps.build.outputs.tags }}
    env:
      IMAGE_NAME: bootc-example
      REGISTRY: ghcr.io/${{ github.repository_owner }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Subscribe runner to Red Hat
        run: |
          set -euo pipefail
          echo "Subscribing runner to Red Hat..."
          
          # Register with Red Hat Subscription Manager
          sudo subscription-manager register \
            --username="${{ secrets.RH_USERNAME }}" \
            --password="${{ secrets.RH_PASSWORD }}" \
            --auto-attach
          
          # Enable necessary repositories
          sudo subscription-manager repos --enable rhel-9-for-${{ matrix.arch }}-appstream-rpms
          sudo subscription-manager repos --enable rhel-9-for-${{ matrix.arch }}-baseos-rpms
          
          echo "Runner successfully subscribed to Red Hat"

      - name: Log in to Red Hat Registry
        uses: redhat-actions/podman-login@v1
        with:
          registry: registry.redhat.io
          username: ${{ secrets.RH_USERNAME }}
          password: ${{ secrets.RH_PASSWORD }}

      - name: Build platform-specific image with Buildah
        id: build
        uses: redhat-actions/buildah-build@v2
        with:
          image: ${{ env.IMAGE_NAME }}
          tags: |
            latest-${{ matrix.arch }}
            ${{ github.sha }}-${{ matrix.arch }}
          platforms: ${{ matrix.platform }}
          containerfiles: |
            ./Containerfile
          extra-args: |
            --pull=always

      - name: Setup empty Docker config
        run: |
          mkdir -p $HOME/.docker
          echo '{ "auths": {} }' > $HOME/.docker/config.json

      - name: Log in to GitHub Container Registry
        uses: redhat-actions/podman-login@v1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push platform-specific image to GHCR
        id: push
        uses: redhat-actions/push-to-registry@v2
        with:
          image: ${{ steps.build.outputs.image }}
          tags: ${{ steps.build.outputs.tags }}
          registry: ${{ env.REGISTRY }}

      - name: Unsubscribe runner from Red Hat
        if: always()
        run: |
          set +e  # Don't fail the job if unsubscribe fails
          echo "Unsubscribing runner from Red Hat..."
          
          # Get host ID for cloud inventory cleanup
          HOST_ID=$(cat /etc/rhsm/host_id 2>/dev/null || echo "")
          
          if [ -n "$HOST_ID" ]; then
            echo "Cleaning up Red Hat Cloud inventory for host: $HOST_ID"
            # Clean up from Red Hat Cloud inventory
            for uuid in $(curl -s -u "${{ secrets.RH_USERNAME }}:${{ secrets.RH_PASSWORD }}" \
              "https://cloud.redhat.com/api/inventory/v1/hosts?fqdn=$HOST_ID" | \
              grep -o '"id":"[^"]*' | grep -o '[^"]*$' || true); do
              if [ -n "$uuid" ]; then
                curl -s -u "${{ secrets.RH_USERNAME }}:${{ secrets.RH_PASSWORD }}" \
                  -X DELETE "https://cloud.redhat.com/api/inventory/v1/hosts/$uuid" \
                  -H "accept: */*" || true
              fi
            done
          fi
          
          # Unregister from subscription manager
          sudo subscription-manager unregister || true
          sudo subscription-manager clean || true
          
          echo "Runner unsubscription completed"

  # Job: Create multi-platform manifest
  create-manifest:
    name: Create multi-platform manifest
    needs: [setup, build-image]
    runs-on: ubuntu-latest
    env:
      IMAGE_NAME: bootc-example
      REGISTRY: ghcr.io/${{ github.repository_owner }}
    outputs:
      manifest-latest: ${{ steps.create.outputs.manifest-latest }}
      manifest-sha: ${{ steps.create.outputs.manifest-sha }}
    steps:
      - name: Log in to GitHub Container Registry
        uses: redhat-actions/podman-login@v1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-platform manifest
        id: create
        run: |
          set -euo pipefail
          
          IMAGE_BASE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          LATEST_MANIFEST="${IMAGE_BASE}:latest"
          SHA_MANIFEST="${IMAGE_BASE}:${{ github.sha }}"
          
          echo "Creating multi-platform manifests..."
          echo "Latest manifest: $LATEST_MANIFEST"
          echo "SHA manifest: $SHA_MANIFEST"
          
          # Remove existing manifests if they exist
          podman manifest rm "$LATEST_MANIFEST" 2>/dev/null || true
          podman manifest rm "$SHA_MANIFEST" 2>/dev/null || true
          
          # Create new manifests
          podman manifest create "$LATEST_MANIFEST"
          podman manifest create "$SHA_MANIFEST"
          
          # Add platform-specific images to manifests
          IFS=',' read -ra PLATFORM_ARRAY <<< "${{ needs.setup.outputs.platforms }}"
          for PLATFORM in "${PLATFORM_ARRAY[@]}"; do
            ARCH="${PLATFORM#linux/}"
            PLATFORM_LATEST="${IMAGE_BASE}:latest-${ARCH}"
            PLATFORM_SHA="${IMAGE_BASE}:${{ github.sha }}-${ARCH}"
            
            echo "Processing platform: $PLATFORM (arch: $ARCH)"
            echo "  Adding $PLATFORM_LATEST to latest manifest"
            echo "  Adding $PLATFORM_SHA to SHA manifest"
            
            # Add to manifests with proper architecture specification
            podman manifest add --arch "$ARCH" --os "linux" "$LATEST_MANIFEST" "docker://$PLATFORM_LATEST"
            podman manifest add --arch "$ARCH" --os "linux" "$SHA_MANIFEST" "docker://$PLATFORM_SHA"
          done
          
          echo "Inspecting created manifests..."
          podman manifest inspect "$LATEST_MANIFEST"
          podman manifest inspect "$SHA_MANIFEST"
          
          echo "Pushing multi-platform manifests..."
          podman manifest push --all "$LATEST_MANIFEST" "docker://$LATEST_MANIFEST"
          podman manifest push --all "$SHA_MANIFEST" "docker://$SHA_MANIFEST"
          
          echo "Multi-platform manifests created and pushed successfully!"
          echo "manifest-latest=$LATEST_MANIFEST" >> $GITHUB_OUTPUT
          echo "manifest-sha=$SHA_MANIFEST" >> $GITHUB_OUTPUT

  # Matrix job: Build artifacts for each platform/format combination
  build-artifacts:
    name: Build artifacts
    needs: [setup, build-image, create-manifest]
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    runs-on: ${{ matrix.runner }}
    env:
      REGISTRY: ghcr.io/${{ github.repository_owner }}
      IMAGE_NAME: bootc-example
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Subscribe runner to Red Hat
        run: |
          set -euo pipefail
          echo "Subscribing runner to Red Hat..."
          
          # Register with Red Hat Subscription Manager
          sudo subscription-manager register \
            --username="${{ secrets.RH_USERNAME }}" \
            --password="${{ secrets.RH_PASSWORD }}" \
            --auto-attach
          
          # Enable necessary repositories
          sudo subscription-manager repos --enable rhel-9-for-${{ matrix.arch }}-appstream-rpms
          sudo subscription-manager repos --enable rhel-9-for-${{ matrix.arch }}-baseos-rpms
          
          echo "Runner successfully subscribed to Red Hat"

      - name: Parse platform
        id: platform
        run: |
          echo "arch=${{ matrix.arch }}" >> $GITHUB_OUTPUT
          echo "safe_arch=${{ matrix.arch }}" >> $GITHUB_OUTPUT

      - name: Set up QEMU (only for cross-platform builds if needed)
        if: matrix.platform != 'linux/amd64' && matrix.runner == 'ubuntu-latest'
        uses: docker/setup-qemu-action@v3

      - name: Enable binfmt_misc (only for emulated builds)
        if: matrix.platform != 'linux/amd64' && matrix.runner == 'ubuntu-latest'
        run: |
          docker run --rm --privileged multiarch/qemu-user-static --reset -p yes || echo "binfmt setup completed"

      - name: Log in to GitHub Container Registry
        uses: redhat-actions/podman-login@v1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create config.toml if it doesn't exist
        run: |
          if [ ! -f config.toml ]; then
            cat > config.toml << 'EOF'
          [[runner]]
          name = "org.osbuild.rhel90"
          label = "rhel-9.0-x86_64"
          distro = "rhel-90"
          EOF
          fi

      - name: Build artifacts for each format
        run: |
          set -euo pipefail
          
          # Use the multi-platform manifest image for artifact building
          IMAGE="${{ needs.create-manifest.outputs.manifest-sha }}"
          PLATFORM="${{ matrix.platform }}"
          ARCH="${{ matrix.arch }}"
          
          echo "Building artifacts from multi-platform image: $IMAGE"
          echo "Target platform: $PLATFORM"
          echo "Target architecture: $ARCH"
          
          # Parse formats from job output
          IFS=',' read -ra FORMATS <<< "${{ needs.setup.outputs.formats }}"
          
          # Create output directory
          mkdir -p ./bootc-exports/$ARCH
          
          for FORMAT in "${FORMATS[@]}"; do
            echo "Building $FORMAT for $PLATFORM"
            
            IMAGE_NAME_TAG=$(basename "$IMAGE")
            SANITIZED_NAME_TAG=$(echo "$IMAGE_NAME_TAG" | sed 's/:/_/')
            DIR_NAME=$(echo "$SANITIZED_NAME_TAG" | sed 's/[^A-Za-z0-9._-]/_/g')
            DIR_NAME=${DIR_NAME}-${FORMAT}
            
            OUTPUT_DIR="./bootc-exports/$ARCH/$DIR_NAME"
            mkdir -p "$OUTPUT_DIR"
            
            # Pull the multi-platform image and let podman select the right arch
            echo "Pulling multi-platform image: $IMAGE"
            podman pull --platform=$PLATFORM $IMAGE
            
            echo "Building $FORMAT artifact for $ARCH architecture"
            
            # Run bootc-image-builder
            sudo podman run \
              --platform=$PLATFORM \
              --rm \
              --privileged \
              --pull=newer \
              --security-opt label=type:unconfined_t \
              -v ./config.toml:/config.toml:z \
              -v "$PWD/$OUTPUT_DIR:/output" \
              -v /var/lib/containers/storage:/var/lib/containers/storage \
              registry.redhat.io/rhel9/bootc-image-builder:latest \
              --target-arch $ARCH \
              --type $FORMAT \
              --use-librepo=True \
              $IMAGE
            
            echo "Artifact built successfully in $OUTPUT_DIR"
            ls -la "$OUTPUT_DIR"
            
            # Upload artifact to OCI registry - use original image base for diskimage repo
            IMAGE_BASE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
            OCI_DISK_IMAGE_REPO=${IMAGE_BASE}/diskimage-${FORMAT}
            OCI_IMAGE_TAG=${{ github.sha }}-${ARCH}
            
            # Create manifest
            sudo podman manifest create ${OCI_DISK_IMAGE_REPO}:${OCI_IMAGE_TAG} || true
            
            # Determine artifact type and file path
            case "$FORMAT" in
              "anaconda-iso")
                ARTIFACT_TYPE="application/vnd.diskimage.iso"
                FILE_PATH="$OUTPUT_DIR/bootiso/install.iso"
                ;;
              "qcow2")
                ARTIFACT_TYPE="application/vnd.diskimage.qcow2"
                FILE_PATH="$OUTPUT_DIR/qcow2/disk.qcow2"
                ;;
              "vmdk")
                ARTIFACT_TYPE="application/vnd.diskimage.vmdk"
                FILE_PATH="$OUTPUT_DIR/vmdk/disk.vmdk"
                ;;
              "raw")
                ARTIFACT_TYPE="application/vnd.diskimage.raw"
                FILE_PATH="$OUTPUT_DIR/image/disk.raw"
                ;;
              *)
                echo "Unknown format: $FORMAT"
                continue
                ;;
            esac
            
            # Check if file exists
            if [ ! -f "$FILE_PATH" ]; then
              echo "Error: Expected file not found at $FILE_PATH"
              echo "Available files:"
              find "$OUTPUT_DIR" -type f
              continue
            fi
            
            echo "Adding artifact to manifest"
            sudo podman manifest add \
              --artifact --artifact-type $ARTIFACT_TYPE \
              --arch $ARCH --os=linux \
              ${OCI_DISK_IMAGE_REPO}:${OCI_IMAGE_TAG} \
              "$FILE_PATH"
            
            echo "Pushing manifest to registry"
            sudo podman manifest push --all \
              ${OCI_DISK_IMAGE_REPO}:${OCI_IMAGE_TAG} \
              docker://${OCI_DISK_IMAGE_REPO}:${OCI_IMAGE_TAG}
            
            echo "Successfully pushed $FORMAT artifact for $ARCH"
          done

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: bootc-artifacts-${{ steps.platform.outputs.safe_arch }}
          path: ./bootc-exports/
          retention-days: 7

      - name: Unsubscribe runner from Red Hat
        if: always()
        run: |
          set +e  # Don't fail the job if unsubscribe fails
          echo "Unsubscribing runner from Red Hat..."
          
          # Get host ID for cloud inventory cleanup
          HOST_ID=$(cat /etc/rhsm/host_id 2>/dev/null || echo "")
          
          if [ -n "$HOST_ID" ]; then
            echo "Cleaning up Red Hat Cloud inventory for host: $HOST_ID"
            # Clean up from Red Hat Cloud inventory
            for uuid in $(curl -s -u "${{ secrets.RH_USERNAME }}:${{ secrets.RH_PASSWORD }}" \
              "https://cloud.redhat.com/api/inventory/v1/hosts?fqdn=$HOST_ID" | \
              grep -o '"id":"[^"]*' | grep -o '[^"]*$' || true); do
              if [ -n "$uuid" ]; then
                curl -s -u "${{ secrets.RH_USERNAME }}:${{ secrets.RH_PASSWORD }}" \
                  -X DELETE "https://cloud.redhat.com/api/inventory/v1/hosts/$uuid" \
                  -H "accept: */*" || true
              fi
            done
          fi
          
          # Unregister from subscription manager
          sudo subscription-manager unregister || true
          sudo subscription-manager clean || true
          
          echo "Runner unsubscription completed"

  # Summary job
  summary:
    name: Build Summary
    needs: [setup, build-image, create-manifest, build-artifacts]
    runs-on: ubuntu-latest
    if: always()
    env:
      IMAGE_NAME: bootc-example
      REGISTRY: ghcr.io/${{ github.repository_owner }}
    steps:
      - name: Print build summary
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "### Multi-platform Images" >> $GITHUB_STEP_SUMMARY
          echo "- Latest: ${{ needs.create-manifest.outputs.manifest-latest }}" >> $GITHUB_STEP_SUMMARY
          echo "- SHA: ${{ needs.create-manifest.outputs.manifest-sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- Platforms: ${{ needs.setup.outputs.platforms }}" >> $GITHUB_STEP_SUMMARY
          echo "- Artifact Formats: ${{ needs.setup.outputs.formats }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Platform-specific Images" >> $GITHUB_STEP_SUMMARY
          IFS=',' read -ra PLATFORM_ARRAY <<< "${{ needs.setup.outputs.platforms }}"
          for PLATFORM in "${PLATFORM_ARRAY[@]}"; do
            ARCH="${PLATFORM#linux/}"
            echo "- $ARCH: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}-${ARCH}" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Build Status" >> $GITHUB_STEP_SUMMARY
          echo "- Setup: ${{ needs.setup.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Base Image Build: ${{ needs.build-image.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Manifest Creation: ${{ needs.create-manifest.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Artifact Build: ${{ needs.build-artifacts.result }}" >> $GITHUB_STEP_SUMMARY